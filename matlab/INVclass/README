There are three directories that contain the object oriented
matlab  inversion code; some routines from other directories
(e.g., I/O routines for ModEM model and data files) are also 
needed.   The three main directories are INVclass, MT2D and 
MT3D

INVclass: contains generic inversion classes, as follows:

1)  Four abstract class definitions which together define the
basic data objects and methods required by the various inversion
algorithms.   The include the model parameter vector m, 
the data vector d, the Model covariance Cm, and sensitivity
or Jacobian J.   Specific instances are defined for
   2D and 3D MT.   The names should be self explanatory.

   ModelParameter.m
       specific instances of this class: 
		MT2D/MT2DmodelParam.m
		MT3D/MT3DmodelParam.m
   DataVector.m
       specific instances of this class: 
		MT2D/MT2DZ.m
		MT3D/MT3DZ.m
   ModelCovariance.m
       specific instances of this class: 
		MT2D/MT2DmodelCov.m  (ad-hoc covariance smoother for 2D)
		MT2D/MT2D_laplace.m  (Laplacian smoothing for 2D)
		MT3D/MT3DmodelCov.m  (ad-hoc covariance smoother for 3D)
   Sensitivity.m
	specific instance of this class:
		SensitivityIndirect.m (indirect sensitivity calculation:
					call ModEM to compute J*m, J'*d etc.
                ProjSensMTX.m    Storage of "projected sensitivity matrix"
                                    as generated with hybrid schemes
                MT2D/MT2Dsens.m  Full storage sensitivity matrix for 2D
                MT3D/MT3Dsens.m  Full storage sensitivity matrix for 3D


2) Inversion classes, which contain actual algorithms for inversion.
These make use of the instances of the abstract classes noted above, 
plus some supporting classes or functions outlined below.
   GN.m    This supports a range of Gauss-Newton type schemes, including
           OCCAM, DCG, and the so-called hybrid and multi-transmitter
           methods I have been working on.   There are a number of "fossil"
           routines in this class; not all may work or make sense anymore.
   NLCG.m  This is under development; not yet debugged!

3) Representer matrix class, RepMat.m : routines to represent the data space
cross-product matrix:     R = CdInv J Cm J' CdInv.   There is a single class
that supports a number of cases.   The representer matrix object depends
on a sensitivity object J.   This can be stored as an array of model parameters
(one for each real data), or represent an operator (i.e., of class
SensitivityIndirect).   In  any event the product R*b is defined.   When
the full J is stored, R can be formed, factored (eigenvector decomposition)
and the equation system Rb = d can be solved.   Routines like CG and J_bidag
can also use an R object (or any type) to solve the system Rb=d approximately,
or to generate a Lanczos decomposition (which can be used to generate a new
instance of a sensitivity object with full storage--a ProjSensMTX object.
This in turn can be used as the basis for a new representer matrix object,
which can be formed, factored, etc.

   RepMat.m

         NOTE: there is a matlab routine called repmat.m, so this 
                    class should be renamed!

4)  Iteration control objects, InvIterControl.m  : these provide objects
which are used to control convergence (maximum number of iterations or steps,
tolerances, etc.) and to record and display convergence behavior.  The same
objects are used for multiple purposes (CG iteration, outer loop iterations,
etc.)  To do this there are many properties defined, only some of which are
used for a specific application.

   InvIterControl.m

5)  Generic (or quasi-generic) routines to support iterative solvers.
    The idea is that these use standard methods like * + - dot and thus
     can be applied to equations expressed in terms of objects in any 
     general class which defines these basic operations
     CG.m   conjugate gradients solution of a symmetric positive-definite
                system
     J_bidiag.m   Lanczos bi-diagonalization of an instance of super-class
                     Sensitivity
