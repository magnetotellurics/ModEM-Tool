Inv

**********************************************************************
************       Inversion Algorithm Subroutines    ****************
**********************************************************************
**********************************************************************
>>> CG
Solves the symetric system Ax = b by conjugate gradients

Usage: [x,CGiter] = CG(A,b,CGiter);

This version assumes A is an actual matlab matrix and b
  is an actual matlab vector.  

On input CGiter is a structure with two fields:
	.maxit and .tol
On output CGiter contains also .niter (number of iterations)
	and .rerr(niter) an array with relative error    
	at each iteration
**********************************************************************

**********************************************************************
>>> CGdat
An abstract DCG scheme; not tested yet
Now b is a data space object, which must have
      plusDat, minusDat, and cTimesDat implemented;
Also A is an abstract matrix, which must have 
      multAdat implemented to multiply A times a data
      vector object.   This is just a first cut test;
      not clear what sense this makes
CGiter is a structure with convergence criteria
**********************************************************************

**********************************************************************
>>> DCG
Data space conjugate gradients driver routine, using
    the crudest approach: make the sensitivity matrix explicitly,
    form the cross-product (representer) matrix and solve with CG.
This does the outer loop iterations.
More a benchmark/debugging aid than anything

Usage: [m,pred,DCGiterAll,GNiter] = DCG(d,lambda,m0,Cm,m)

    Inputs: d = data vector
            lambda = regularization parameter
            m0 = prior model
            Cm = model covariance parameter structure
            m = optional starting model; by default use m0
    Outputs:m = solution
            pred = predicted data
            DCGiterAll =  cell array of DCGiter structures (see CG)
              giving convergence info for each inner loop iteration
              sequence
            GNiter = structure giving total number of iterations 
              and RMS after completion of each inner loop
**********************************************************************

**********************************************************************
>>> dataSpaceCG
Solve data space equations for a fixed value of the damping
    parameter lambda, starting from model parameter m = m0+mn

Usage:  [mn1] = dataSpaceCG(d,lambda,mn,m0)
**********************************************************************

**********************************************************************
>>> NLCG
NLCG driver routine.
   
Usage: [mInv,pred,NLCGiter] = NLCG(d,lambda,m_0,CmHalf);

Inputs:      d = data vector
               lambda = regularization parameter
               m_0 = prior model (also starting model)
               CmHalf = covariance structure (for square root) 
Outputs:      mInv = solution (model parameter structure)
               pred = predicted data
               NLCGiter = structure giving convergence info
Note that convergence criteria are set by a call to setNLCG;
    edit this file to change
**********************************************************************

**********************************************************************
>>> lineSearchNA
Line search for conjugate gradients, following simple scheme
described in Newman and Alumbaugh, using model transformation
approach for preconditioning

Usage: [mTilde,m,r,Pen,nMod] = lineSearchNA(mTilde,CmHalf,...
					 lambda,d,m_0,Pen,h,g);

Inputs:  mTilde = current model solution,
                      transformed as Cm^{-1/2} (m-m0)
         CmHalf = model covariance parameters
         lambda = regularization parameter
         m_0 = prior model
         Pen = value of penalty functional at mTilde
         h = search direction
         g = gradient at mTilde

Outputs: mTilde = new model solution, transformed
         m =  new model solution Cm^{1/2}mTilde+m0
         r = new data residual
         Pen = penalty functional evaluated at new model
         nMode = number of forward modeling calls required by search
**********************************************************************

**********************************************************************
>>> occamCurve
Computes new perturbation to prior (m_mu) and
     corresponding normalized misfit X2, for inversion
     of data vector d starting from model m, with
     damping parameter nu = mu^{-1}

   Usage:     [X2,nu,m_mu] = occamCurve(d,m_n,m_0,CmHalf,nu,Tol);
              [X2,nu,m_mu] = occamCurve(d,m_n,m_0,CmHalf,nu);
	       [X2,nu] = occamCurve(d,m_n,m_0,CmHalf);
  If nu is omitted on input, generates
     n_nu values, uniformly space in log
     determined from spectrum of representer matrix
     and returns the normalized misfit sum of squares as a function
     regularization parameter nu
  If Tol is present, fits to tolerance (starting from nu)
**********************************************************************

**********************************************************************
>>> occamCurveRepCG
%  Computes X2 misfit curve as a function of nu 
%    (damping parameter = mu^{-1}) for specified values of nu;
%    Using hybrid CG/GN scheme with fixed K
%
%   Usage: [X2,nu,m_mu] = occamCurveRepCG(d,m,m_0,CmHalf,K);
%   Usage: [X2,nu,m_mu] = occamCurveRepCG(d,m,m_0,CmHalf,K,nu);
%   Usage: [X2,nu,m_mu] = occamCurveRepCG(d,m,m_0,CmHalf,K,nu,Tol);
%	[X2,nu] = occamCurve;
%  If nu is omitted on input, generates
%   n_nu values, uniformly space in log
%   determined from spectrum of representer matrix
%  If Tol is included, m_mu fits to tolerance; otherwise
%   m_mu minimizes misfit
%  Other inputs:
%    K = # of CG iteration
%    d = full data vector
%    m_n = current model  (WITH/WITHOUT m_0????)
%    m_0 = prior model 
%    CmHalf = model covariance structure
**********************************************************************

**********************************************************************
>>>  occamCurveRepCG
Computes X2 misfit curve as a function of nu
(damping parameter = mu^{-1}) for specified values of nu;
Using hybrid CG/GN scheme with K determined from CGopt parameters

Usage: [X2,nu,m_mu,X2linFreq,Jproj,Uproj] =
                occamCurveRepCG(d,m_n,m_0,CmHalf,CGopt,nu,Tol);

Inputs:
   Required: CGopt = Hybrid scheme control parameters
                        (see cgRep for documentation)
              d = full data vector
              m_n = current model  (with prior subtracted)
              m_0 = prior model
              CmHalf = model covariance structure
   Optional: nu = regularization parameter, or array of such
                 If nu is omitted on input, the routine generates
                  an array of nu values, using the spectrum of the
                  sensitivity matrix (which is computed in this routine)
              Tol = tolerance to fit to
                  If Tol is included, m_mu fits to tolerance; otherwise
                     m_mu minimizes misfit

Outputs:     X2 = SS misfit for each regularization parameter
               nu = the regularization parameters for which solution is
                       computed
               m_mu = the solution (with prior subtracted) that fits
                   to tolerance or minimizes misfit
               X2linFreq = cell array of linearized misfits predicted
                       for each truncation level, up to the max for 
                      which repCG computations are done.
               Jproj = sensitivities for projected data vectors
               Uproj = data vector projection matrix
**********************************************************************

**********************************************************************
>>> cgRep3
Does the first stage in hybrid CG/Occam scheme
    given starting model (minus prior m_0) 
This version is modified to allow using only "significant"
       CG search directions, with criteria from CGopt
Replaces cgRep

Usage: [Jproj,dProj,U] = cgRep(K,dh,m);

Inputs:  CGopt.K = max number of CG steps per frequency
         CGopt.nUseMin = min number of CG steps per frequency
         CGopt.tol = number of CG steps per frequency
         dh = corrected residual (dHat)
         CmHalf = model parameter covariance data structure

Ouputs:  Jproj = Jacobian for projected data vector
         X2All = data misfit predicted (linearize) for all
                     truncation levels up to maximum set in CGopt
         U = data projection matrix
**********************************************************************



**********************************************************************
****************   Representer/crossproduct matrix routines   ********
**********************************************************************
**********************************************************************
>>> mkRepMat
Construct representer matrix, given full Jacobian, data
   error variances (in data structure), and model covariance;
   then do eigenvector decomposition
Returns everything in a structure R

 Usage:  [R] = mkRepMat(Jin,dIn,CmHalf);
 Inputs: Jin = Jacobian
	  dIn = data structure, used for Cd (data error variances)
         CmHalf = model parameter covariance parameter structure
 OutputL R.M = representer matrix, normalized by data error covariance
             = Cd^{-1/2} R Cd^{-1/2}
         R.V, R.lambda = eigenvectors and eigenvalues of R.M
         R.CdInv = Cd{-1/2}, for full data structure (i.e., all
            frequencies), stored as a simple real vector
**********************************************************************

**********************************************************************
>>> RepSolve
Given the representer matrix and damping parameter
      solve [R + nu I ] b = dh, compute m = J^T b
      as coded, still need to multiply by Cm to get
      representer solution  
  Usage:  [m_mu] = RepSolve(R,nu,dh,m);
  Inputs: R = representer matrix
          nu = regularization parameter
          d  = dHat data space vector
          m  = model parameter template
**********************************************************************

**********************************************************************
>>> compSVD
Given computed sensitivity matrix (cell array of
     of model parameters, one for each observation)
     and covariance parameter structure CmHalf,
     compute structure containing SVD of CmHalf*J
     or eigenvector decomposition of J^T Cm J
     (depending on 1/0 argument compSVD)

Usage: [S] = SVD_J(J,CmHalf,compSVD);
**********************************************************************

**********************************************************************
>>> SVD_solve(S,nu,CmHalf,d)

Given factored structure S (computed from sensitivity
    matrix J and covariance structure CmHalf) solve
    data space equations with regularization parameter
    nu and data structure d (data error covariance is
    stored in d, along with data)

Usage: [m_mu] = SVD_solve(S,nu,CmHalf,d);
**********************************************************************

**********************************************************************
>>> multA_d
Matrix vector multiply  required for DCG:
       [Cd^{-1/2] J Cm J^T Cd^{-1/2} + mu I ] dIn = dOut

Usage:  [dOut] = multA_d(dIn,m,Cm,mu);
**********************************************************************

**********************************************************************
>>> bidiagJ
Computes K-step Lanczos bidagonalization of Cm^{1/2} J Cd^{-1/2}
Depending on whether LU = 'L' or 'U' implements eitther
bi-diag1 (Lower triangular) or bi-diag2 (upper triangular)
decompositions of Paige and Saunders (1982).

Usage: [U,B,V] = bidiagJ(J,CmHalf,K,LU)

Note that the implementation here is highly specialized to
the Jacobian data structure, where J{1} is a cell array containing
the RHS data object (in turn a cell array of structures, one for
each transmitter), and J{2} is the Jacobian (a cell array of modelParam
data structures, one for each data point).

Returns:	U = cell array of K (K+1 for LU = 'L') data objects,
  		V = cell array of K model parameter objects
  		B = bidiagonal matrix; U and V give orthonormal basis
      	         	for the decomposition for the data and model 
			spaces respectively
**********************************************************************

**********************************************************************
>>> multA_m
Matrix vector multiply  required for MCG:
     [Cm^{1/2] J^T J Cm^{1/2} + mu I ] mIn = mOut

Usage:  [mOut] = multA_d(mIn,mu);
**********************************************************************





**********************************************************************
*****************    Residuals and gradients   ***********************
**********************************************************************
**********************************************************************
>>> resid
Compute residual r = d-f(m), possibly nomalized by data
standard deviations

Usage : [r] = resid(d,m,NORMALIZE);
    Inputs: data vector d, model parameter m
		NORMALIZE is optional
    Output:  residuals in dataSpace object r
**********************************************************************

**********************************************************************
>>> gradMisfit
Generates direction of steepest descent of misfit functional,
including real and imaginary parts (only
real part is actual gradient), separately
for each frequency 

Usage:  [g] = gradMisfit(m,DIRECT)
  Input:  DIRECT = 0 to use computed sensitivities
    for gradient calculation.  Default is to
    compute gradients with call to Fortran program
  Output: g is cell array of conductivity
    parameter structures, two for each frequency
  Current model, prior model, grid are assumed already
   set in global
**********************************************************************




**********************************************************************
*****************   Initialization and setup   ***********************
**********************************************************************
**********************************************************************
>>> SETnu
Simple initialization of array of damping parameters
to try in our crude search implementation

Usage:  [nu] = SETnu(lambda1)
**********************************************************************

**********************************************************************
>>> setDCGiter
initialize PCG iteration control parameter data
   structure

Usage:  [PCGiter] = setDCGiter()
**********************************************************************

**********************************************************************
>>> setGNiter
initialize GN iteration control parameter data
   structure

Usage:  [GNiter] = setGNiter()
**********************************************************************

**********************************************************************
>>> setNLCGiter
initialize NLCG iteration control parameter data

Usage:  [maxIt,Tol] = setNLCGiter();
**********************************************************************



**********************************************************************
****************       Miscellaneous            **********************
**********************************************************************
**********************************************************************
>>> mergeMTX

Merges sensitivies from adjacent bands.  

Usage:   [Jmerge,d_merge] = mergeMTX(J,d,nBands)

Note that J is a cell array with two cells: first contains 
cell array of data objects (one per frequency), second is 
cell array of model parameter objects (one per observation).

Inputs:      J = input sensitivity object
             d = compatible data object (not verified)
               nBands = number of frequency "bands" for output

Outputs:     Jmerge = merged output sensitivity structure;
                  sensitivities (Jmerge{2}) are normalized by 
                   dividing by error bars obtained from input d
            d_merge = output data object (also copied into
                   first cell of Jmerge) reorganized into nBands
                   frequency groupings, normalized so that data
                   errors are now 1.
THIS IS NOT SO SENSIBLE: WHY NOT JUST MERGE THE
THE DATA OBJECTS?  (Trying to preserve uniform
errors for each frequency, but this is a bad idea
anyway!  And it is not necessary!)
**********************************************************************



**********************************************************************
****************       Driver/Test scripts      **********************
**********************************************************************
**********************************************************************
>>> OccamTest.m
Script for testing Occam scheme
in this version full sensitivity is calculated, loaded, and stored
as a global structure
**********************************************************************

**********************************************************************
>>> DCGtest.m
Script for testing DCG ... needs more documentation when actually
    debugged
**********************************************************************

**********************************************************************
>>> DCGtestList.m
Script for testing DCG, doing multiple runs ... needs 
more documentation when actually debugged; calls DCGtestS.m
**********************************************************************

**********************************************************************
>>> DCGtestS.m
A variant on DCGtest designed to streamline running DCG for
different cases.  The following parameters have to be set
	runType = 'DCG';
	modelID = '2a';
	run = '_1';
	MODE = 'JT';
	ErrFac = 1.0;
	priorCond = .02;
	lambda = 1;
Then this script can be run, with input and output file names
constructed in a standard way from the above parameters.
DCGtestList.m is used to set these parameters, then call DCGtestS
for each desired run.
**********************************************************************

**********************************************************************
>>> NLCGtest.m
Driver script for testing NLCG ... needs more documentation when actually
debugged
**********************************************************************
